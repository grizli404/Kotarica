define(['dart_sdk', 'packages/web3dart/src/crypto/random_bridge.dart', 'packages/web3dart/src/utils/typed_data.dart', 'packages/pointycastle/stream/salsa20.dart', 'packages/web3dart/src/utils/uuid.dart'], (function load__packages__web3dart__credentials_dart(dart_sdk, packages__web3dart__src__crypto__random_bridge$46dart, packages__web3dart__src__utils__typed_data$46dart, packages__pointycastle__stream__salsa20$46dart, packages__web3dart__src__utils__uuid$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const typed_data = dart_sdk.typed_data;
  const async = dart_sdk.async;
  const convert = dart_sdk.convert;
  const _native_typed_data = dart_sdk._native_typed_data;
  const _js_helper = dart_sdk._js_helper;
  const _interceptors = dart_sdk._interceptors;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const crypto$ = packages__web3dart__src__crypto__random_bridge$46dart.crypto;
  const random_bridge = packages__web3dart__src__crypto__random_bridge$46dart.src__crypto__random_bridge;
  const typed_data$ = packages__web3dart__src__utils__typed_data$46dart.src__utils__typed_data;
  const pbkdf2 = packages__pointycastle__stream__salsa20$46dart.key_derivators__pbkdf2;
  const api = packages__pointycastle__stream__salsa20$46dart.key_derivators__api;
  const hmac = packages__pointycastle__stream__salsa20$46dart.macs__hmac;
  const sha256 = packages__pointycastle__stream__salsa20$46dart.digests__sha256;
  const scrypt = packages__pointycastle__stream__salsa20$46dart.key_derivators__scrypt;
  const ctr = packages__pointycastle__stream__salsa20$46dart.stream__ctr;
  const aes_fast = packages__pointycastle__stream__salsa20$46dart.block__aes_fast;
  const api$ = packages__pointycastle__stream__salsa20$46dart.api;
  const uuid$ = packages__web3dart__src__utils__uuid$46dart.src__utils__uuid;
  var credentials$ = Object.create(dart.library);
  var $length = dartx.length;
  var $toUpperCase = dartx.toUpperCase;
  var $toLowerCase = dartx.toLowerCase;
  var $_get = dartx._get;
  var $hashCode = dartx.hashCode;
  var $toString = dartx.toString;
  var $_equals = dartx._equals;
  var $plus = dartx['+'];
  var $setRange = dartx.setRange;
  var $truncate = dartx.truncate;
  var $sublist = dartx.sublist;
  var $addAll = dartx.addAll;
  var $buffer = dartx.buffer;
  dart._checkModuleNullSafetyMode(false);
  var T = {
    EthereumAddressL: () => (T.EthereumAddressL = dart.constFn(dart.legacy(credentials$.EthereumAddress)))(),
    Uint8ListL: () => (T.Uint8ListL = dart.constFn(dart.legacy(typed_data.Uint8List)))(),
    MsgSignatureL: () => (T.MsgSignatureL = dart.constFn(dart.legacy(crypto$.MsgSignature)))(),
    StringL: () => (T.StringL = dart.constFn(dart.legacy(core.String)))(),
    IdentityMapOfStringL$dynamic: () => (T.IdentityMapOfStringL$dynamic = dart.constFn(_js_helper.IdentityMap$(T.StringL(), dart.dynamic)))(),
    IdentityMapOfStringL$StringL: () => (T.IdentityMapOfStringL$StringL = dart.constFn(_js_helper.IdentityMap$(T.StringL(), T.StringL())))(),
    ObjectL: () => (T.ObjectL = dart.constFn(dart.legacy(core.Object)))(),
    IdentityMapOfStringL$ObjectL: () => (T.IdentityMapOfStringL$ObjectL = dart.constFn(_js_helper.IdentityMap$(T.StringL(), T.ObjectL())))(),
    MapOfStringL$dynamic: () => (T.MapOfStringL$dynamic = dart.constFn(core.Map$(T.StringL(), dart.dynamic)))(),
    MapLOfStringL$dynamic: () => (T.MapLOfStringL$dynamic = dart.constFn(dart.legacy(T.MapOfStringL$dynamic())))(),
    intL: () => (T.intL = dart.constFn(dart.legacy(core.int)))(),
    JSArrayOfintL: () => (T.JSArrayOfintL = dart.constFn(_interceptors.JSArray$(T.intL())))(),
    CipherParametersL: () => (T.CipherParametersL = dart.constFn(dart.legacy(api$.CipherParameters)))(),
    ParametersWithIVOfCipherParametersL: () => (T.ParametersWithIVOfCipherParametersL = dart.constFn(api$.ParametersWithIV$(T.CipherParametersL())))(),
    Uint8ListLAndUint8ListLToMsgSignatureL: () => (T.Uint8ListLAndUint8ListLToMsgSignatureL = dart.constFn(dart.fnType(T.MsgSignatureL(), [T.Uint8ListL(), T.Uint8ListL()])))()
  };
  var T$Eval = Object.assign({
    _: () => T$Eval
  }, T);
  var S = {
    _: () => S
  };
  var S$Eval = Object.assign({
    _: () => S$Eval
  }, S);
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.fn(crypto$.sign, T.Uint8ListLAndUint8ListLToMsgSignatureL());
    }
  }, false);
  var C = [void 0];
  var I = [
    "file:///C:/Users/Daka/Downloads/flutter_windows_2.0.1-stable/flutter/.pub-cache/hosted/pub.dartlang.org/web3dart-1.2.3/lib/src/credentials/address.dart",
    "package:web3dart/credentials.dart",
    "file:///C:/Users/Daka/Downloads/flutter_windows_2.0.1-stable/flutter/.pub-cache/hosted/pub.dartlang.org/web3dart-1.2.3/lib/src/credentials/credentials.dart"
  ];
  var addressBytes$ = dart.privateName(credentials$, "EthereumAddress.addressBytes");
  credentials$.EthereumAddress = class EthereumAddress extends core.Object {
    get addressBytes() {
      return this[addressBytes$];
    }
    set addressBytes(value) {
      super.addressBytes = value;
    }
    static fromPublicKey(publicKey) {
      return new credentials$.EthereumAddress.new(crypto$.publicKeyToAddress(publicKey));
    }
    static fromHex(hex, opts) {
      let enforceEip55 = opts && 'enforceEip55' in opts ? opts.enforceEip55 : false;
      if (!dart.test(credentials$.EthereumAddress._basicAddress.hasMatch(hex))) {
        dart.throw(new core.ArgumentError.value(hex, "address", "Must be a hex string with a length of 40, optionally prefixed with \"0x\""));
      }
      if (!dart.test(enforceEip55) && (hex[$toUpperCase]() === hex || hex[$toLowerCase]() === hex)) {
        return new credentials$.EthereumAddress.new(crypto$.hexToBytes(hex));
      }
      let address = crypto$.strip0x(hex);
      let hash = crypto$.bytesToHex(crypto$.keccakAscii(address[$toLowerCase]()));
      for (let i = 0; i < 40; i = i + 1) {
        let hashedPos = core.int.parse(hash[$_get](i), {radix: 16});
        if (dart.notNull(hashedPos) > 7 && address[$_get](i)[$toUpperCase]() !== address[$_get](i) || dart.notNull(hashedPos) <= 7 && address[$_get](i)[$toLowerCase]() !== address[$_get](i)) {
          dart.throw(new core.ArgumentError.new("Address has invalid case-characters and is" + "thus not EIP-55 conformant, rejecting. Address was: " + dart.str(hex)));
        }
      }
      return new credentials$.EthereumAddress.new(crypto$.hexToBytes(hex));
    }
    get hex() {
      return crypto$.bytesToHex(this.addressBytes, {include0x: true, forcePadLength: 40});
    }
    get hexNo0x() {
      return crypto$.bytesToHex(this.addressBytes, {include0x: false, forcePadLength: 40});
    }
    get hexEip55() {
      let hex = this.hexNo0x[$toLowerCase]();
      let hash = crypto$.bytesToHex(crypto$.keccakAscii(this.hexNo0x));
      let eip55 = new core.StringBuffer.new("0x");
      for (let i = 0; i < hex.length; i = i + 1) {
        if (dart.notNull(core.int.parse(hash[$_get](i), {radix: 16})) >= 8) {
          eip55.write(hex[$_get](i)[$toUpperCase]());
        } else {
          eip55.write(hex[$_get](i));
        }
      }
      return eip55.toString();
    }
    toString() {
      return this.hex;
    }
    _equals(other) {
      if (other == null) return false;
      return this === other || T.EthereumAddressL().is(other) && other.hex == this.hex;
    }
    get hashCode() {
      return dart.hashCode(this.hex);
    }
  };
  (credentials$.EthereumAddress.new = function(addressBytes) {
    this[addressBytes$] = addressBytes;
    if (!(addressBytes[$length] === 20)) dart.assertFailed(null, I[0], 16, 16, "addressBytes.length == addressByteLength");
    ;
  }).prototype = credentials$.EthereumAddress.prototype;
  dart.addTypeTests(credentials$.EthereumAddress);
  dart.addTypeCaches(credentials$.EthereumAddress);
  dart.setMethodSignature(credentials$.EthereumAddress, () => ({
    __proto__: dart.getMethods(credentials$.EthereumAddress.__proto__),
    toString: dart.fnType(dart.legacy(core.String), []),
    [$toString]: dart.fnType(dart.legacy(core.String), []),
    _equals: dart.fnType(dart.legacy(core.bool), [dart.dynamic]),
    [$_equals]: dart.fnType(dart.legacy(core.bool), [dart.dynamic])
  }));
  dart.setGetterSignature(credentials$.EthereumAddress, () => ({
    __proto__: dart.getGetters(credentials$.EthereumAddress.__proto__),
    hex: dart.legacy(core.String),
    hexNo0x: dart.legacy(core.String),
    hexEip55: dart.legacy(core.String),
    hashCode: dart.legacy(core.int),
    [$hashCode]: dart.legacy(core.int)
  }));
  dart.setLibraryUri(credentials$.EthereumAddress, I[1]);
  dart.setFieldSignature(credentials$.EthereumAddress, () => ({
    __proto__: dart.getFields(credentials$.EthereumAddress.__proto__),
    addressBytes: dart.finalFieldType(dart.legacy(typed_data.Uint8List))
  }));
  dart.defineExtensionMethods(credentials$.EthereumAddress, ['toString', '_equals']);
  dart.defineExtensionAccessors(credentials$.EthereumAddress, ['hashCode']);
  dart.defineLazy(credentials$.EthereumAddress, {
    /*credentials$.EthereumAddress._basicAddress*/get _basicAddress() {
      return core.RegExp.new("^(0x)?[0-9a-f]{40}", {caseSensitive: false});
    },
    /*credentials$.EthereumAddress.addressByteLength*/get addressByteLength() {
      return 20;
    }
  }, true);
  var _padTo32 = dart.privateName(credentials$, "_padTo32");
  credentials$.Credentials = class Credentials extends core.Object {
    get isolateSafe() {
      return false;
    }
    sign(payload, opts) {
      let chainId = opts && 'chainId' in opts ? opts.chainId : null;
      return async.async(T.Uint8ListL(), (function* sign() {
        let signature = (yield this.signToSignature(payload, {chainId: chainId}));
        let r = this[_padTo32](crypto$.intToBytes(signature.r));
        let s = this[_padTo32](crypto$.intToBytes(signature.s));
        let v = crypto$.intToBytes(core._BigIntImpl.from(signature.v));
        return typed_data$.uint8ListFromList(r[$plus](s)[$plus](v));
      }).bind(this));
    }
    signPersonalMessage(payload, opts) {
      let chainId = opts && 'chainId' in opts ? opts.chainId : null;
      let prefix = "Ethereum Signed Message:\n" + dart.toString(payload[$length]);
      let prefixBytes = convert.ascii.encode(prefix);
      let concat = typed_data$.uint8ListFromList(prefixBytes[$plus](payload));
      return this.sign(concat, {chainId: chainId});
    }
    [_padTo32](data) {
      let t0;
      if (!(dart.notNull(data[$length]) <= 32)) dart.assertFailed(null, I[2], 52, 12, "data.length <= 32");
      if (data[$length] === 32) return data;
      t0 = _native_typed_data.NativeUint8List.new(32);
      return (() => {
        t0[$setRange](32 - dart.notNull(data[$length]), 32, data);
        return t0;
      })();
    }
  };
  (credentials$.Credentials.new = function() {
    ;
  }).prototype = credentials$.Credentials.prototype;
  dart.addTypeTests(credentials$.Credentials);
  dart.addTypeCaches(credentials$.Credentials);
  dart.setMethodSignature(credentials$.Credentials, () => ({
    __proto__: dart.getMethods(credentials$.Credentials.__proto__),
    sign: dart.fnType(dart.legacy(async.Future$(dart.legacy(typed_data.Uint8List))), [dart.legacy(typed_data.Uint8List)], {chainId: dart.legacy(core.int)}, {}),
    signPersonalMessage: dart.fnType(dart.legacy(async.Future$(dart.legacy(typed_data.Uint8List))), [dart.legacy(typed_data.Uint8List)], {chainId: dart.legacy(core.int)}, {}),
    [_padTo32]: dart.fnType(dart.legacy(typed_data.Uint8List), [dart.legacy(typed_data.Uint8List)])
  }));
  dart.setGetterSignature(credentials$.Credentials, () => ({
    __proto__: dart.getGetters(credentials$.Credentials.__proto__),
    isolateSafe: dart.legacy(core.bool)
  }));
  dart.setLibraryUri(credentials$.Credentials, I[1]);
  dart.defineLazy(credentials$.Credentials, {
    /*credentials$.Credentials._messagePrefix*/get _messagePrefix() {
      return "Ethereum Signed Message:\n";
    }
  }, true);
  var privateKey$ = dart.privateName(credentials$, "EthPrivateKey.privateKey");
  var isolateSafe = dart.privateName(credentials$, "EthPrivateKey.isolateSafe");
  var _cachedAddress = dart.privateName(credentials$, "_cachedAddress");
  credentials$.EthPrivateKey = class EthPrivateKey extends credentials$.Credentials {
    get privateKey() {
      return this[privateKey$];
    }
    set privateKey(value) {
      super.privateKey = value;
    }
    get isolateSafe() {
      return this[isolateSafe];
    }
    set isolateSafe(value) {
      super.isolateSafe = value;
    }
    static createRandom(random) {
      let key = crypto$.generateNewPrivateKey(random);
      return new credentials$.EthPrivateKey.new(crypto$.intToBytes(key));
    }
    extractAddress() {
      return async.async(T.EthereumAddressL(), (function* extractAddress() {
        let t0;
        t0 = this[_cachedAddress];
        return t0 == null ? this[_cachedAddress] = new credentials$.EthereumAddress.new(crypto$.publicKeyToAddress(crypto$.privateKeyBytesToPublic(this.privateKey))) : t0;
      }).bind(this));
    }
    signToSignature(payload, opts) {
      let chainId = opts && 'chainId' in opts ? opts.chainId : null;
      return async.async(T.MsgSignatureL(), (function* signToSignature() {
        let signature = credentials$._globalSign(crypto$.keccak256(payload), this.privateKey);
        let chainIdV = chainId != null ? dart.notNull(signature.v) - 27 + (dart.notNull(chainId) * 2 + 35) : signature.v;
        return new crypto$.MsgSignature.new(signature.r, signature.s, chainIdV);
      }).bind(this));
    }
  };
  (credentials$.EthPrivateKey.new = function(privateKey) {
    this[_cachedAddress] = null;
    this[isolateSafe] = true;
    this[privateKey$] = privateKey;
    ;
  }).prototype = credentials$.EthPrivateKey.prototype;
  (credentials$.EthPrivateKey.fromHex = function(hex) {
    this[_cachedAddress] = null;
    this[isolateSafe] = true;
    this[privateKey$] = crypto$.hexToBytes(hex);
    ;
  }).prototype = credentials$.EthPrivateKey.prototype;
  dart.addTypeTests(credentials$.EthPrivateKey);
  dart.addTypeCaches(credentials$.EthPrivateKey);
  dart.setMethodSignature(credentials$.EthPrivateKey, () => ({
    __proto__: dart.getMethods(credentials$.EthPrivateKey.__proto__),
    extractAddress: dart.fnType(dart.legacy(async.Future$(dart.legacy(credentials$.EthereumAddress))), []),
    signToSignature: dart.fnType(dart.legacy(async.Future$(dart.legacy(crypto$.MsgSignature))), [dart.legacy(typed_data.Uint8List)], {chainId: dart.legacy(core.int)}, {})
  }));
  dart.setLibraryUri(credentials$.EthPrivateKey, I[1]);
  dart.setFieldSignature(credentials$.EthPrivateKey, () => ({
    __proto__: dart.getFields(credentials$.EthPrivateKey.__proto__),
    privateKey: dart.finalFieldType(dart.legacy(typed_data.Uint8List)),
    [_cachedAddress]: dart.fieldType(dart.legacy(credentials$.EthereumAddress)),
    isolateSafe: dart.finalFieldType(dart.legacy(core.bool))
  }));
  credentials$._KeyDerivator = class _KeyDerivator extends core.Object {};
  (credentials$._KeyDerivator.new = function() {
    ;
  }).prototype = credentials$._KeyDerivator.prototype;
  dart.addTypeTests(credentials$._KeyDerivator);
  dart.addTypeCaches(credentials$._KeyDerivator);
  dart.setLibraryUri(credentials$._KeyDerivator, I[1]);
  var name = dart.privateName(credentials$, "_PBDKDF2KeyDerivator.name");
  credentials$._PBDKDF2KeyDerivator = class _PBDKDF2KeyDerivator extends credentials$._KeyDerivator {
    get name() {
      return this[name];
    }
    set name(value) {
      super.name = value;
    }
    deriveKey(password) {
      let t0;
      let impl = (t0 = new pbkdf2.PBKDF2KeyDerivator.new(credentials$._PBDKDF2KeyDerivator.mac), (() => {
        t0.init(new api.Pbkdf2Parameters.new(this.salt, this.iterations, this.dklen));
        return t0;
      })());
      return impl.process(password);
    }
    encode() {
      return new (T.IdentityMapOfStringL$dynamic()).from(["c", this.iterations, "dklen", this.dklen, "prf", "hmac-sha256", "salt", crypto$.bytesToHex(this.salt)]);
    }
  };
  (credentials$._PBDKDF2KeyDerivator.new = function(iterations, salt, dklen) {
    this[name] = "pbkdf2";
    this.iterations = iterations;
    this.salt = salt;
    this.dklen = dklen;
    ;
  }).prototype = credentials$._PBDKDF2KeyDerivator.prototype;
  dart.addTypeTests(credentials$._PBDKDF2KeyDerivator);
  dart.addTypeCaches(credentials$._PBDKDF2KeyDerivator);
  dart.setMethodSignature(credentials$._PBDKDF2KeyDerivator, () => ({
    __proto__: dart.getMethods(credentials$._PBDKDF2KeyDerivator.__proto__),
    deriveKey: dart.fnType(dart.legacy(typed_data.Uint8List), [dart.legacy(typed_data.Uint8List)]),
    encode: dart.fnType(dart.legacy(core.Map$(dart.legacy(core.String), dart.dynamic)), [])
  }));
  dart.setLibraryUri(credentials$._PBDKDF2KeyDerivator, I[1]);
  dart.setFieldSignature(credentials$._PBDKDF2KeyDerivator, () => ({
    __proto__: dart.getFields(credentials$._PBDKDF2KeyDerivator.__proto__),
    iterations: dart.finalFieldType(dart.legacy(core.int)),
    salt: dart.finalFieldType(dart.legacy(typed_data.Uint8List)),
    dklen: dart.finalFieldType(dart.legacy(core.int)),
    name: dart.finalFieldType(dart.legacy(core.String))
  }));
  dart.defineLazy(credentials$._PBDKDF2KeyDerivator, {
    /*credentials$._PBDKDF2KeyDerivator.mac*/get mac() {
      return new hmac.HMac.new(new sha256.SHA256Digest.new(), 64);
    }
  }, true);
  var name$ = dart.privateName(credentials$, "_ScryptKeyDerivator.name");
  credentials$._ScryptKeyDerivator = class _ScryptKeyDerivator extends credentials$._KeyDerivator {
    get name() {
      return this[name$];
    }
    set name(value) {
      super.name = value;
    }
    deriveKey(password) {
      let t0;
      let impl = (t0 = new scrypt.Scrypt.new(), (() => {
        t0.init(new api.ScryptParameters.new(this.n, this.r, this.p, this.dklen, this.salt));
        return t0;
      })());
      return impl.process(password);
    }
    encode() {
      return new (T.IdentityMapOfStringL$dynamic()).from(["dklen", this.dklen, "n", this.n, "r", this.r, "p", this.p, "salt", crypto$.bytesToHex(this.salt)]);
    }
  };
  (credentials$._ScryptKeyDerivator.new = function(dklen, n, r, p, salt) {
    this[name$] = "scrypt";
    this.dklen = dklen;
    this.n = n;
    this.r = r;
    this.p = p;
    this.salt = salt;
    ;
  }).prototype = credentials$._ScryptKeyDerivator.prototype;
  dart.addTypeTests(credentials$._ScryptKeyDerivator);
  dart.addTypeCaches(credentials$._ScryptKeyDerivator);
  dart.setMethodSignature(credentials$._ScryptKeyDerivator, () => ({
    __proto__: dart.getMethods(credentials$._ScryptKeyDerivator.__proto__),
    deriveKey: dart.fnType(dart.legacy(typed_data.Uint8List), [dart.legacy(typed_data.Uint8List)]),
    encode: dart.fnType(dart.legacy(core.Map$(dart.legacy(core.String), dart.dynamic)), [])
  }));
  dart.setLibraryUri(credentials$._ScryptKeyDerivator, I[1]);
  dart.setFieldSignature(credentials$._ScryptKeyDerivator, () => ({
    __proto__: dart.getFields(credentials$._ScryptKeyDerivator.__proto__),
    dklen: dart.finalFieldType(dart.legacy(core.int)),
    n: dart.finalFieldType(dart.legacy(core.int)),
    r: dart.finalFieldType(dart.legacy(core.int)),
    p: dart.finalFieldType(dart.legacy(core.int)),
    salt: dart.finalFieldType(dart.legacy(typed_data.Uint8List)),
    name: dart.finalFieldType(dart.legacy(core.String))
  }));
  var privateKey$0 = dart.privateName(credentials$, "Wallet.privateKey");
  var _derivator$ = dart.privateName(credentials$, "Wallet._derivator");
  var _password$ = dart.privateName(credentials$, "Wallet._password");
  var _iv$ = dart.privateName(credentials$, "Wallet._iv");
  var _id$ = dart.privateName(credentials$, "Wallet._id");
  var _derivator = dart.privateName(credentials$, "_derivator");
  var _password = dart.privateName(credentials$, "_password");
  var _iv = dart.privateName(credentials$, "_iv");
  var _id = dart.privateName(credentials$, "_id");
  var _encryptPrivateKey = dart.privateName(credentials$, "_encryptPrivateKey");
  credentials$.Wallet = class Wallet extends core.Object {
    get privateKey() {
      return this[privateKey$0];
    }
    set privateKey(value) {
      super.privateKey = value;
    }
    get [_derivator]() {
      return this[_derivator$];
    }
    set [_derivator](value) {
      super[_derivator] = value;
    }
    get [_password]() {
      return this[_password$];
    }
    set [_password](value) {
      super[_password] = value;
    }
    get [_iv]() {
      return this[_iv$];
    }
    set [_iv](value) {
      super[_iv] = value;
    }
    get [_id]() {
      return this[_id$];
    }
    set [_id](value) {
      super[_id] = value;
    }
    get uuid() {
      return uuid$.formatUuid(this[_id]);
    }
    toJson() {
      let ciphertextBytes = this[_encryptPrivateKey]();
      let map = new (T.IdentityMapOfStringL$ObjectL()).from(["crypto", new (T.IdentityMapOfStringL$ObjectL()).from(["cipher", "aes-128-ctr", "cipherparams", new (T.IdentityMapOfStringL$StringL()).from(["iv", crypto$.bytesToHex(this[_iv])]), "ciphertext", crypto$.bytesToHex(ciphertextBytes), "kdf", this[_derivator].name, "kdfparams", this[_derivator].encode(), "mac", credentials$.Wallet._generateMac(this[_derivator].deriveKey(this[_password]), ciphertextBytes)]), "id", this.uuid, "version", 3]);
      return convert.json.encode(map);
    }
    static createNew(credentials, password, random, opts) {
      let scryptN = opts && 'scryptN' in opts ? opts.scryptN : 8192;
      let passwordBytes = _native_typed_data.NativeUint8List.fromList(convert.utf8.encode(password));
      let dartRandom = new random_bridge.RandomBridge.new(random);
      let salt = dartRandom.nextBytes(32);
      let derivator = new credentials$._ScryptKeyDerivator.new(32, scryptN, 8, 1, salt);
      let uuid = uuid$.generateUuidV4();
      let iv = dartRandom.nextBytes((128 / 8)[$truncate]());
      return new credentials$.Wallet.__(credentials, derivator, passwordBytes, iv, uuid);
    }
    static fromJson(encoded, password) {
      let t0;
      let data = convert.json.decode(encoded);
      let version = dart.dsend(data, '_get', ["version"]);
      if (!dart.equals(version, 3)) {
        dart.throw(new core.ArgumentError.value(version, "version", "Library only supports " + "version 3 of wallet files at the moment. However, the following value" + " has been given:"));
      }
      let crypto = (t0 = dart.dsend(data, '_get', ["crypto"]), t0 == null ? dart.dsend(data, '_get', ["Crypto"]) : t0);
      let kdf = T.StringL().as(dart.dsend(crypto, '_get', ["kdf"]));
      let derivator = null;
      switch (kdf) {
        case "pbkdf2":
        {
          let derParams = T.MapLOfStringL$dynamic().as(dart.dsend(crypto, '_get', ["kdfparams"]));
          if (!dart.equals(derParams[$_get]("prf"), "hmac-sha256")) {
            dart.throw(new core.ArgumentError.new("Invalid prf supplied with the pdf: was " + dart.str(derParams[$_get]("prf")) + ", expected hmac-sha256"));
          }
          derivator = new credentials$._PBDKDF2KeyDerivator.new(T.intL().as(derParams[$_get]("c")), _native_typed_data.NativeUint8List.fromList(crypto$.hexToBytes(T.StringL().as(derParams[$_get]("salt")))), T.intL().as(derParams[$_get]("dklen")));
          break;
        }
        case "scrypt":
        {
          let derParams = T.MapLOfStringL$dynamic().as(dart.dsend(crypto, '_get', ["kdfparams"]));
          derivator = new credentials$._ScryptKeyDerivator.new(T.intL().as(derParams[$_get]("dklen")), T.intL().as(derParams[$_get]("n")), T.intL().as(derParams[$_get]("r")), T.intL().as(derParams[$_get]("p")), _native_typed_data.NativeUint8List.fromList(crypto$.hexToBytes(T.StringL().as(derParams[$_get]("salt")))));
          break;
        }
        default:
        {
          dart.throw(new core.ArgumentError.new("Wallet file uses " + dart.str(kdf) + " as key derivation function, which is not supported."));
        }
      }
      let encodedPassword = _native_typed_data.NativeUint8List.fromList(convert.utf8.encode(password));
      let derivedKey = derivator.deriveKey(encodedPassword);
      let aesKey = _native_typed_data.NativeUint8List.fromList(derivedKey[$sublist](0, 16));
      let encryptedPrivateKey = crypto$.hexToBytes(T.StringL().as(dart.dsend(crypto, '_get', ["ciphertext"])));
      let derivedMac = credentials$.Wallet._generateMac(derivedKey, encryptedPrivateKey);
      if (!core.identical(derivedMac, dart.dsend(crypto, '_get', ["mac"]))) dart.throw(new core.ArgumentError.new("Could not unlock wallet file. You either supplied the wrong password or the file is corrupted"));
      if (!dart.equals(dart.dsend(crypto, '_get', ["cipher"]), "aes-128-ctr")) {
        dart.throw(new core.ArgumentError.new("Wallet file uses " + dart.str(dart.dsend(crypto, '_get', ["cipher"])) + " as cipher, but only aes-128-ctr is supported."));
      }
      let iv = _native_typed_data.NativeUint8List.fromList(crypto$.hexToBytes(T.StringL().as(dart.dsend(dart.dsend(crypto, '_get', ["cipherparams"]), '_get', ["iv"]))));
      let aes = credentials$.Wallet._initCipher(false, aesKey, iv);
      let privateKey = aes.process(_native_typed_data.NativeUint8List.fromList(encryptedPrivateKey));
      let credentials = new credentials$.EthPrivateKey.new(privateKey);
      let id = uuid$.parseUuid(T.StringL().as(dart.dsend(data, '_get', ["id"])));
      return new credentials$.Wallet.__(credentials, derivator, encodedPassword, iv, id);
    }
    static _generateMac(dk, ciphertext) {
      let t0;
      let macBody = (t0 = T.JSArrayOfintL().of([]), (() => {
        t0[$addAll](dk[$sublist](16, 32));
        t0[$addAll](ciphertext);
        return t0;
      })());
      return crypto$.bytesToHex(crypto$.keccak256(typed_data$.uint8ListFromList(macBody)));
    }
    static _initCipher(forEncryption, key, iv) {
      let t0;
      t0 = new ctr.CTRStreamCipher.new(new aes_fast.AESFastEngine.new());
      return (() => {
        t0.init(false, new (T.ParametersWithIVOfCipherParametersL()).new(new api$.KeyParameter.new(key), iv));
        return t0;
      })();
    }
    [_encryptPrivateKey]() {
      let derived = this[_derivator].deriveKey(this[_password]);
      let aesKey = typed_data.Uint8List.view(derived[$buffer], 0, 16);
      let aes = credentials$.Wallet._initCipher(true, aesKey, this[_iv]);
      return aes.process(this.privateKey.privateKey);
    }
  };
  (credentials$.Wallet.__ = function(privateKey, _derivator, _password, _iv, _id) {
    this[privateKey$0] = privateKey;
    this[_derivator$] = _derivator;
    this[_password$] = _password;
    this[_iv$] = _iv;
    this[_id$] = _id;
    ;
  }).prototype = credentials$.Wallet.prototype;
  dart.addTypeTests(credentials$.Wallet);
  dart.addTypeCaches(credentials$.Wallet);
  dart.setMethodSignature(credentials$.Wallet, () => ({
    __proto__: dart.getMethods(credentials$.Wallet.__proto__),
    toJson: dart.fnType(dart.legacy(core.String), []),
    [_encryptPrivateKey]: dart.fnType(dart.legacy(core.List$(dart.legacy(core.int))), [])
  }));
  dart.setGetterSignature(credentials$.Wallet, () => ({
    __proto__: dart.getGetters(credentials$.Wallet.__proto__),
    uuid: dart.legacy(core.String)
  }));
  dart.setLibraryUri(credentials$.Wallet, I[1]);
  dart.setFieldSignature(credentials$.Wallet, () => ({
    __proto__: dart.getFields(credentials$.Wallet.__proto__),
    privateKey: dart.finalFieldType(dart.legacy(credentials$.EthPrivateKey)),
    [_derivator]: dart.finalFieldType(dart.legacy(credentials$._KeyDerivator)),
    [_password]: dart.finalFieldType(dart.legacy(typed_data.Uint8List)),
    [_iv]: dart.finalFieldType(dart.legacy(typed_data.Uint8List)),
    [_id]: dart.finalFieldType(dart.legacy(typed_data.Uint8List))
  }));
  dart.defineLazy(credentials$, {
    /*credentials$._globalSign*/get _globalSign() {
      return C[0] || CT.C0;
    }
  }, true);
  dart.trackLibraries("packages/web3dart/credentials.dart", {
    "package:web3dart/credentials.dart": credentials$
  }, {
    "package:web3dart/credentials.dart": ["src/credentials/address.dart", "src/credentials/credentials.dart", "src/credentials/wallet.dart"]
  }, '{"version":3,"sourceRoot":"","sources":["src/credentials/address.dart","src/credentials/credentials.dart","src/credentials/wallet.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../packages/web3dart/credentials.dart.lib.js"}');
  // Exports:
  return {
    credentials: credentials$
  };
}));

//# sourceMappingURL=credentials.dart.lib.js.map
